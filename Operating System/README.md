# **운영체제**

참고 문헌: Operating System Concepts(
Abraham Silberschatz , Peter B. Galvin , Greg Gagne)<br>
참고 강의: KOCW 양희재 교수님 운영체제 강의

---

## <h1> 운영체제란?

컴퓨터의 하드웨어를 관리하는 소프트웨어, 하드웨어와 소프트웨어 사이의 **인터페이스**이다.

<img src="img/OS_intro.JPG"></img><br/><br/>

컴퓨터 시스템 자원들을 효율적으로 관리하여

- 성능을 높이고
- 사용자의 편의를 높여준다.<br>
  . . 컴퓨터 하드웨어를 관리하는 프로그램

<img src="img/OS_service.JPG"></img><br/>

---

## 운영체제 서론

<br>

**-Booting**
<br>

컴퓨터의 구조를 단순화하면 이러하다.<br>

<img src="img/OS_BootLoader.JPG"></img><br/>

- Processor: 일반적인 CPU
- ROM: 비휘발성, 전원이 꺼져도 내용이 유지된다. 보조메모리, 디스크
- RAM: 휘발성, 전원이 꺼지면 내용이 지워진다. 흔히 말하는 메인 메모리

컴퓨터의 전원을 키면 CPU에서 ROM에 있는 내용을 읽는다.
ROM에는 **POST**,**부트 로더** 가 저장되어 있다. POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로 컴퓨터의 상태를 검사한다.
그 다음 부트 로더가 실행된다. 부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 RAM 에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다

---

**-Shell**

Command Interpreter

<br>

운영체제는 크게보면 커널(Kernel), 쉘(Shell) 로 구성된다.
<br>

<img src="img/OS_Shell.JPG"></img><br/>

- 커널 : 실제로 관리하는 프로그램. 뜻 그대로 핵심
- 쉘 : 사용자의 명령을 화면에 보여주는 역할 <br>
  쉘은 사용자가 요청하는 **_명령어를 해석하여 커널에 요청하고 결과를 화면에 보여준다._**
  <br>
  <br>

**-Application on OS**<br>

프로그램은 특정 운영체제에 맞춰서 만든다. 하나의 프로그램은 같은 CPU일지라도 다른 운영체제에서는 제대로 작동하지 않는다. **System call**의 종류가 다르기 때문이다.
<br>

<img src="img/OS_Application.JPG"></img><br/>

애플리케이션은 위의 그림과 같이 운영체제 위에서 수행한다. 즉, 하드웨어 자원을 직접적으로 사용하지 않고 운영체제가 **제공하는 자원**만을 사용할 수 있다.
<br>

---

## 운영체제 역사

<br>

**-초기의 컴퓨터**<br>

초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더(입력), 프로세서(연산), 프린터(출력)이다.
<br><br>

**-Batch Processing System(일괄 처리 시스템)**<br>

-최초의 운영체제<br>

오퍼레이터에서 **컴파일-링크-로드**의 일련의 작업을 수행했는데, 이 업무를 **자동화**한 것이 **Batch Processing System(일괄 처리 시스템)**이다. 업무를 수행 하는 프로그램을 메모리안에 할당해주었다.
<br><br>

**-Multiprogramming System(다중 프로그래밍 시스템)**<br>

과거에 컴퓨터의 메모리에는 단 하나의 사용자 프로그램을 할당해서 사용했다.
프로그램이 실행될 때 **CPU 작업과 I/O 작업이 번갈아가며 동작**하는데 I/O 작업이 수행되는 동안 CPU가 일하지 않는 **_idle_** 상태가 된다.<br>
그리고 I/O 작업의 속도는 CPU와 비교했을 때 매우 느려서 idle 상태의 비율이 높았다.
이러한 비효율적인 루틴을 해결하기 위해 다중 프로그래밍이 나왔다.<br><br>
. . . A 라는 애플리케이션이 I/O 작업을 수행한다면, 그사이 CPU가 B라는 애플리케이션의 작업을 수행하여 CPU의 효율을 높이고자 하였다.<br>

. . . CPU 스케줄링, 메모리 관리, 보호 문제 등장

<br>

**-Time Sharing System(시분할 시스템)**<br>

시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 **대화 형식**이 가능해졌다.
컴퓨터가 너무 비쌌기 때문에 여러명이서 하나의 컴퓨터에 단말기(terminal)형태로 사용했다.

멀티프로그래밍에서는 한 사람이 CPU를 점유하고 있으면 다른 사용자는 CPU를 사용할 수 없다. 그러므로 다른 사용자들은 CPU를 점유 중인 프로그램이 I/O 작업으로 전환되기 전까지 사용할 수 없었고 이는 매우 비효율적이었다.

이에 CPU가 하나의 프로그램을 수행하는 **시간을 제한**하는, **time-sharing system** 이 등장했다. 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 했고, 이는 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 주었다.<br>
. . . 1960년대 UNIX 대표적인 시분할 시스템.<br><br>
<img src="img/OS_timeSharingSystem.JPG"></img><br/><br>

시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 역시 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.<br>

---

## Interrupt(인터럽트)

<br>

인터럽트는 CPU에게 보내는 전기 신호로서 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 **정해진 코드**를 수행한다. 그리고 수행이 끝나면 원래 위치로 돌아간다.<br>

. . .'정해진 코드'를 **인터럽트 서비스 루틴(ISR), 인터럽트 핸들러(Interrupt Handler)** 라고 한다.
<br><br>

인터럽트의 종류 3가지

- 하드웨어 인터럽트<br>
  . . . 가장 빈번하게 발생함. I/O 장치로 부터의 요청 등
  <br><br>
- 소프트웨어 인터럽트<br>
  . . .운영체제의 서비스를 사용하기 위해 운영체제에 요청하는 작업. . . [System call](##system-call)
  <br><br>
- 내부 인터럽트<br>
  . . .프로그램을 수행하는 도중에 발생하는 예외상황. Overflow 등
  <br><br>

<br>

---

## Dual Mode(이중모드)

<br>

한 컴퓨터를 여러 사람이 사용한다.(ex) 서버 등)<br>
한 사람의 고의, 실수로 치명적인 영향을 줄 수 있다.

이를 방지하기 위해 사용자 프로그램은 **치명적인 명령**은 사용하지 못하도록 하였다.

. . . CPU가 동작하는 모드를 두 가지로 나눈다.

- User mode
- Kernel mode

<br>

<img src="img/OS_DualMode.JPG"></img><br/>

하드웨어/소프트웨어 인터럽트가 발생하면 관리자 모드로 작업을 수행하고 다시 사용자 모드로 바꿔준다. <br>
**컴퓨터 자원**에 직접 접근할 수 없다.
<br><br>

---

## 운영체제 서비스

<br>

### 프로세스 관리

<br>

프로세스 관리는 운영체제 기능 중 가장 중요한 기능 중 하나이다. 프로세스와 프로그램은 기본적으로 구분된다. 프로세스는 **실제 메인 메모리에서 실행 중인 프로그램**을 말한다.
<br>
<br>

- 프로세스의 생성과 소멸(creation, deletion)
- 프로세스 활동 일시 중지, 활동 재게(suspend, resume)
- 프로세스간 통신(IPC)
- 프로세스간 동기화(synchronization)
- 교착상태 처리(deadlock handling)

<br>

### 주기억장치 관리

<br>
주기억장치 즉, 메인 메모리는 프로그램이 실행되기 위한 공간이다. CPU는 오직 메인 메모리에 있는 프로그램(프로세스)하고만 소통할 수 있다. OS는 메인 메모리를 효율적으로 사용하도록 관리한다.
<br>
<br>

- 프로세스에게 메모리 공간 할당(allocation)
- 메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시
- 프로세스 종료 시 메모리 회수(deallocation)
- 메모리의 효과적 사용
- 가상 메모리: 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.

<br>

### 파일 관리

<br>

디스크는 물리적으로 Track과 sector로 구성되어 있으며, 여기서 파일이라는 논리적 관점으로 데이터를 바라보고 관리하는 것이다.
복잡한 과정으로 하드디스크에 저장되어 있는 것을 사용자가 편리하게 사용할 수 있도록 파일이라는 논리적 형태로 운영체제에서 관리하여 보여준다.
<br>
<br>

- 파일의 생성과 삭제(file creation, deletion)
- 디렉토리(Directory)의 생성과 삭제
- 기본 동작 지원: open, close, read, write, create, delete
- Track/sector - file 간의 매핑(mapping)
- 백업(Backup)

<br><br>

### 보조기억장치 관리

<br>

보조기억장치는 대표적으로 하드 디스크이다. 하드 디스크에서 아무 것도 저장되어 있지 않는 공간을 block이라 하는데, 보조기억장치 관리는 이를 관리하는 것이다.

- 빈 공간 관리(Free space management)
- 저장공간 할당(Storage allocation)
- 디스크 스케줄링(Disk scheduling)

<br><br>

### 입출력 장치 관리(I/O device management)

<br>

입출력 장치에는 키보드, 마우스, 프린터, 스피커, 마이크 등이 있다. 입출력 장치 관리는 이와 같은 여러 입출력 장치를 사용하기 위해 존재한다.

- 장치 드라이브(Device drivers)
- 입출력 장치의 성능향상: buffering, caching, spooling

<br><br>

## System call

<br>

<img src="img/OS_Syscall.JPG"></img><br/>
<br>

- 운영체제의 커널이 제공하는 서비스에 대해, **응용 프로그램의 요청**에 따라 커널에 접근하기 위한 인터페이스이다.

<br><br>

---

## 프로세스 관리

<br>

프로세스란?<br>
> 메인 메모리에 할당되어 __실행중인 상태__ 인 프로그램<br>

<br>
 프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무 일도 하지 않는 상태이다.<Br>
 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변한다.<br> 프로세스는 job, task 등으로 불리기도 한다
 <br>

<br>
프로세스 상태<br>
<br>

- New: 프로그램이 메인 메모리에 할당된다.
- Ready: 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다.
- Running: CPU가 해당 프로세스를 실행한다.
- Waiting: 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다. (해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아가야 한다.)
- Terminated: 프로세스가 완전히 종료된다.<br>
<br>
<img src="img/OS_ProcessState.JPG"></img><br/>

<br>

### PCB

<br>
 
__프로세스에 대한 모든 정보__ 가 모여있는 곳으로, Task Control Block(TCB) 이라고도 한다.<br>
PCB안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 program counter(pc), register값, MMU정보, CPU점유 시간 등이 포함되어 있다.<br>
PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있다.

<Br>

<img src="img/OS_PCB.JPG"></img><br/>
<br>

. . . Context Switching 에 필요한 정보를 PCB에 저장한다.



---

## 프로세스 동기화

<br>

---

## Critical section(임계구역)

<br>

---
