# **운영체제**

참고 문헌: Operating System Concepts(
Abraham Silberschatz , Peter B. Galvin , Greg Gagne)<br>
참고 강의: KOCW 양희재 교수님 운영체제 강의

---

## <h1> 운영체제란?

컴퓨터의 하드웨어를 관리하는 소프트웨어, 하드웨어와 소프트웨어 사이의 **인터페이스**이다.

<img src="img/OS_intro.JPG"></img><br/><br/>

컴퓨터 시스템 자원들을 효율적으로 관리하여

- 성능을 높이고
- 사용자의 편의를 높여준다.<br>
  . . 컴퓨터 하드웨어를 관리하는 프로그램

<img src="img/OS_service.JPG"></img><br/>

---

## 운영체제 서론

<br>

**-Booting**
<br>

컴퓨터의 구조를 단순화하면 이러하다.<br>

<img src="img/OS_BootLoader.JPG"></img><br/>

- Processor: 일반적인 CPU
- ROM: 비휘발성, 전원이 꺼져도 내용이 유지된다. 보조메모리, 디스크
- RAM: 휘발성, 전원이 꺼지면 내용이 지워진다. 흔히 말하는 메인 메모리

컴퓨터의 전원을 키면 CPU에서 ROM에 있는 내용을 읽는다.
ROM에는 **POST**,**부트 로더** 가 저장되어 있다. POST는 전원이 켜지면 가장 처음에 실행되는 프로그램으로 컴퓨터의 상태를 검사한다.
그 다음 부트 로더가 실행된다. 부트 로더는 하드디스크에 저장되어 있는 운영체제를 찾아서 RAM 에 가지고 온다. 이러한 부트 로더의 과정을 부팅이라고 한다

---

**-Shell**

Command Interpreter

<br>

운영체제는 크게보면 커널(Kernel), 쉘(Shell) 로 구성된다.
<br>

<img src="img/OS_Shell.JPG"></img><br/>

- 커널 : 실제로 관리하는 프로그램. 뜻 그대로 핵심
- 쉘 : 사용자의 명령을 화면에 보여주는 역할 <br>
  쉘은 사용자가 요청하는 **_명령어를 해석하여 커널에 요청하고 결과를 화면에 보여준다._**
  <br>
  <br>

**-Application on OS**<br>

프로그램은 특정 운영체제에 맞춰서 만든다. 같은 CPU에 같은 명령어일지라도 **System call**의 종류가 다르기 때문이다.
<br>

<img src="img/OS_Application.JPG"></img><br/>

애플리케이션은 위의 그림과 같이 운영체제 위에서 수행한다. 즉, 하드웨어 자원을 직접적으로 사용하지 않고 운영체제가 **제공하는 자원**만을 사용할 수 있다.
<br>

---

## 운영체제 역사

<br>

**-초기의 컴퓨터**<br>

초기 컴퓨터는 크게 3가지로 구성되었다. 카드 리더(입력), 프로세서(연산), 프린터(출력)이다.
<br><br>

**-Batch Processing System(일괄 처리 시스템)**<br>

-최초의 운영체제<br>

오퍼레이터에서 **컴파일-링크-로드**의 일련의 작업을 수행했는데, 이 업무를 **자동화**한 것이 **Batch Processing System(일괄 처리 시스템)**이다. 업무를 수행 하는 프로그램을 메모리안에 할당해주었다.
<br><br>

**-Multiprogramming System(다중 프로그래밍 시스템)**<br>

과거에 컴퓨터의 메모리에는 단 하나의 사용자 프로그램을 할당해서 사용했다.
프로그램이 실행될 때 **CPU 작업과 I/O 작업이 번갈아가며 동작**하는데 I/O 작업이 수행되는 동안 CPU가 일하지 않는 **_idle_** 상태가 된다.<br>
그리고 I/O 작업의 속도는 CPU와 비교했을 때 매우 느려서 idle 상태의 비율이 높았다.
이러한 비효율적인 루틴을 해결하기 위해 다중 프로그래밍이 나왔다.<br><br>
. . . A 라는 애플리케이션이 I/O 작업을 수행한다면, 그사이 CPU가 B라는 애플리케이션의 작업을 수행하여 CPU의 효율을 높이고자 하였다.<br>

. . . CPU 스케줄링, 메모리 관리, 보호 문제 등장

<br>

**-Time Sharing System(시분할 시스템)**<br>

시간이 지나 모니터와 키보드를 사용하면서 사용자와 컴퓨터 사이에 **대화 형식**이 가능해졌다.
컴퓨터가 너무 비쌌기 때문에 여러명이서 하나의 컴퓨터에 단말기(terminal)형태로 사용했다.

멀티프로그래밍에서는 한 사람이 CPU를 점유하고 있으면 다른 사용자는 CPU를 사용할 수 없다. 그러므로 다른 사용자들은 CPU를 점유 중인 프로그램이 I/O 작업으로 전환되기 전까지 사용할 수 없었고 이는 매우 비효율적이었다.

이에 CPU가 하나의 프로그램을 수행하는 **시간을 제한**하는, **time-sharing system** 이 등장했다. 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 했고, 이는 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 주었다.<br>
. . . 1960년대 UNIX 대표적인 시분할 시스템.<br><br>
<img src="img/OS_timeSharingSystem.JPG"></img><br/><br>

시분할 시스템을 사용하면서 여러 사용자(프로세스)간에 통신이 가능해졌다. 하지만 여기서도 역시 멀티프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다. 이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.<br>

---

## Interrupt

---

## Dual Mode(이중모드)

<br>

한 컴퓨터를 여러 사람이 사용한다.(ex) 서버 등)<br>
한 사람의 고의, 실수로 치명적인 영향을 줄 수 있다.

이를 방지하기 위해 사용자 프로그램은 **치명적인 명령**은 사용하지 못하도록 하였다.

. . . CPU가 동작하는 모드를 두 가지로 나눈다.

- User mode
- Kernel mode

<br>

<img src="img/OS_DualMode.JPG"></img><br/>

하드웨어/소프트웨어 인터럽트가 발생하면 관리자 모드로 작업을 수행하고 다시 사용자 모드로 바꿔준다. <br>
**컴퓨터 자원**에 직접 접근할 수 없다.
<br><br>

---

## 운영체제 서비스

<br>

---

## 프로세스 관리

<br>

---

## 프로세스 동기화

<br>

---

## Critical section(임계구역)

<br>

---
